{"version":3,"file":"generator.mjs","sources":["../../src/regex.js","../../src/parse-citation.js","../../src/utils.js","../../src/html-transform-browser.js","../../src/generator.js"],"sourcesContent":["/**\n * Captures normal citation in square bracket and in-text citation\n * Citation key start should start with a letter, digit, or _,\n * and contains only alphanumerics and single internal punctuation characters (:.#$%&-+?<>~/),\n *\n * e.g. [-@wadler1990], [@hughes1989, sec 3.4], [see @wadler1990; and @hughes1989, pp. 4]\n * and @wadler1990\n *\n * Group #1 - citation term without [] bracket e.g. -@wadler1990\n * Group #2 - in-text citation term e.g. @wadler1990\n *\n * \\[([^[\\]]*@[^[\\]]+)\\] for group #1\n * (?!\\b)@([a-zA-Z0-9_][a-zA-Z0-9_:.#$%&\\-+?<>~]*) for group #2\n * Use (?!\\b) to avoid email like address e.g. xyx@google.com\n * */\nexport const citeExtractorRe =\n  /\\[([^[\\]]*@[^[\\]]+)\\]|(?!\\b)(@[a-zA-Z0-9_][a-zA-Z0-9_:.#$%&\\-+?<>~]*)/\nexport const citeKeyRe = /@([a-zA-Z0-9_][a-zA-Z0-9_:.#$%&\\-+?<>~]*)/\nexport const citeBracketRe = /\\[.*\\]/\n","/**\n * @typedef CiteItem\n *   Cite item to be passed into citeproc-js\n * @property {string} [id]\n *   The id field is required\n * @property {string} [locator]\n *   A string identifying a page number or other pinpoint location or range within the resource;\n * @property {string} [label]\n *   Path to file\n * @property {string} [prefix]\n *   A string to print before this cite item\n * @property {string} [suffix]\n *   A string to print after this cite item\n * @property {boolean} [suppress-author]\n *   If true, author names will not be included in the citation output for this cite\n * @property {boolean} [author-only]\n *   If true, only the author name will be included in the citation output for this cite\n */\n\nimport { citeBracketRe, citeKeyRe } from './regex.js'\n\nconst locatorMapping = {\n  book: 'book',\n  'bk.': 'book',\n  'bks.': 'book',\n  chapter: 'chapter',\n  'chap.': 'chapter',\n  'chaps.': 'chapter',\n  column: 'column',\n  'col.': 'column',\n  'cols.': 'column',\n  figure: 'figure',\n  'fig.': 'figure',\n  'figs.': 'figure',\n  folio: 'folio',\n  'fol.': 'folio',\n  'fols.': 'folio',\n  number: 'number',\n  'no.': 'number',\n  'nos.': 'number',\n  line: 'line',\n  'l.': 'line',\n  'll.': 'line',\n  note: 'note',\n  'n.': 'note',\n  'nn.': 'note',\n  opus: 'opus',\n  'op.': 'opus',\n  'opp.': 'opus',\n  page: 'page',\n  'p.': 'page',\n  'pp.': 'page',\n  paragraph: 'paragraph',\n  'para.': 'paragraph',\n  'paras.': 'paragraph',\n  part: 'part',\n  'pt.': 'part',\n  'pts.': 'part',\n  section: 'section',\n  'sec.': 'section',\n  'secs.': 'section',\n  'sub verbo': 'sub verbo',\n  's.v.': 'sub verbo',\n  's.vv.': 'sub verbo',\n  verse: 'verse',\n  'v.': 'verse',\n  'vv.': 'verse',\n  volume: 'volume',\n  'vol.': 'volume',\n  'vols.': 'volume',\n  '¶': 'paragraph',\n  '¶¶': 'paragraph',\n  '§': 'section',\n  '§§': 'section',\n}\n\n/**\n * Parses a given citation string and return entries and isComposite flag required for cite-proc.\n * Adapted from https://github.com/Zettlr/Citr/blob/master/lib/citr.ts\n *\n * @param {string} citeString Cite string in the form of '[@item]' or '@item'\n * @return {[CiteItem[], boolean]} [entries, isComposite]\n */\nexport const parseCitation = (citeString) => {\n  /** @type {CiteItem[]} */\n  let entries = []\n  let isComposite = false\n  if (citeBracketRe.test(citeString)) {\n    // Handle citations in the form of [@item1; @item2]\n    const citeItems = citeString.substr(1, citeString.length - 2).split(';')\n    for (const citeItem of citeItems) {\n      // Prefix is the portion before @ e.g. [see @item1] or an empty string\n      let prefix = ''\n      let locator = ''\n      let label = 'page'\n      let suffix = ''\n      const citeChunk = citeItem.split('@')\n      if (citeChunk.length === 1) {\n        throw new Error('Cite key should be in the form of @key')\n      } else if (citeChunk.length > 2) {\n        throw new Error('More than one cite key @ detected, please separate keys with ;')\n      }\n      prefix += citeChunk[0]\n      prefix = prefix.trim()\n\n      // If [-@item1], suppress author\n      let suppressAuthor = citeItem.indexOf('@') > 0 && citeItem[citeItem.indexOf('@') - 1] === '-'\n      if (suppressAuthor) prefix = prefix.substr(0, prefix.length - 1).trim()\n\n      // The citation key can be terminated with a comma or space\n      let commaIndex = citeChunk[1].indexOf(',') + 1\n      // If the commaIndex is 0, this means there was no comma - check for space\n      if (commaIndex === 0) commaIndex = citeChunk[1].indexOf(' ') + 1\n      // Pass undefined to extract everything\n      if (commaIndex <= 0) commaIndex = undefined\n      const citeKey = citeItem.substr(citeItem.indexOf('@'), commaIndex).match(citeKeyRe)[0]\n\n      // We are left with the locator, suffix and label\n      let afterKey = citeItem.split('@')[1].substr(citeKey.length).trim()\n      if (afterKey[0] === ',') afterKey = afterKey.substr(1).trim()\n      // Locator should be in the form of 11-22, 33\n      // Would not work form roman numerals or alphabetical sections\n      const locatorMatch = afterKey.match(/(\\d|-| |,)+/g)\n      if (locatorMatch !== null) {\n        locator = locatorMatch[0].trim()\n        // String before the locator is taken to be the label\n        // Use heuristic from https://pandoc.org/MANUAL.html#citation-syntax to convert locator label to valid\n        // Label has to be one of the following: https://docs.citationstyles.org/en/stable/specification.html#locators\n        label = afterKey.split(locator)[0].trim()\n        label = locatorMapping[label] || 'page'\n        // String after the locator is taken to be the suffix\n        suffix = afterKey.split(locator)[1].trim()\n      } else {\n        // If no locator is found, entire string is assumed to be the suffix\n        suffix = afterKey.trim()\n      }\n\n      entries.push({\n        // Get the first capture group which returns the citekey without @\n        id: citeItem.match(citeKeyRe)[1],\n        locator,\n        label,\n        prefix,\n        suffix,\n        'suppress-author': suppressAuthor,\n      })\n    }\n  } else {\n    // Single item in the form of @item1\n    // See https://citeproc-js.readthedocs.io/en/latest/running.html#special-citation-forms\n    isComposite = true\n    entries = [citeString].map((str) => ({\n      id: str.match(citeKeyRe)[1],\n    }))\n  }\n  return [entries, isComposite]\n}\n","import fetch from 'cross-fetch'\n\nexport const isNode = typeof window === 'undefined'\n\nexport const readFile = async (path) => {\n  if (isValidHttpUrl(path)) {\n    return fetch(path)\n      .then((response) => response.text())\n      .then((data) => data)\n  } else {\n    if (isNode) {\n      return import('fs').then((fs) => fs.readFileSync(path, 'utf8'))\n    } else {\n      throw new Error(`Cannot read non valid URL in node env.`)\n    }\n  }\n}\n\n/**\n * Check if valid URL\n * https://stackoverflow.com/questions/5717093/check-if-a-javascript-string-is-a-url\n *\n * @param {string} str\n * @return {boolean}\n */\nexport const isValidHttpUrl = (str) => {\n  let url\n\n  try {\n    url = new URL(str)\n  } catch (_) {\n    return false\n  }\n\n  return url.protocol === 'http:' || url.protocol === 'https:'\n}\n\n/**\n * Get bibliography by merging options and vfile data\n *\n * @param {import('./generator.js').Options} options\n * @param {import('vfile').VFile} file\n */\nexport const getBibliography = async (options, file) => {\n  let bibliography = ''\n  if (options.bibliography) {\n    bibliography = options.bibliography\n    // @ts-ignore\n  } else if (file?.data?.frontmatter?.bibliography) {\n    // @ts-ignore\n    bibliography = file.data.frontmatter.bibliography\n    // If local path, get absolute path\n    if (!isValidHttpUrl(bibliography)) {\n      if (isNode) {\n        bibliography = await import('path').then((path) =>\n          path.join(options.path || file.cwd, bibliography)\n        )\n      } else {\n        throw new Error(`Cannot read non valid bibliography URL in node env.`)\n      }\n    }\n  }\n\n  return bibliography\n}\n\n/**\n * Load CSL - supports predefined name from config.templates.data or http, file path (nodejs)\n *\n * @param {*} Cite cite object from citation-js\n * @param {string} format CSL name e.g. apa or file path to CSL file\n * @param {string} root optional root path\n */\nexport const loadCSL = async (Cite, format, root = '') => {\n  const config = Cite.plugins.config.get('@csl')\n  if (!Object.keys(config.templates.data).includes(format)) {\n    const cslName = `customCSL-${Math.random().toString(36).slice(2, 7)}`\n    let cslPath = ''\n    if (isValidHttpUrl(format)) cslPath = format\n    else {\n      if (isNode) cslPath = await import('path').then((path) => path.join(root, format))\n    }\n    try {\n      config.templates.add(cslName, await readFile(cslPath))\n    } catch (err) {\n      throw new Error(`Input CSL option, ${format}, is invalid or is an unknown file.`)\n    }\n    return cslName\n  } else {\n    return format\n  }\n}\n\n/**\n * Load locale - supports predefined name from config.locales.data or http, file path (nodejs)\n *\n * @param {*} Cite cite object from citation-js\n * @param {string} format locale name\n * @param {string} root optional root path\n */\nexport const loadLocale = async (Cite, format, root = '') => {\n  const config = Cite.plugins.config.get('@csl')\n  if (!Object.keys(config.locales.data).includes(format)) {\n    let localePath = ''\n    if (isValidHttpUrl(format)) localePath = format\n    else {\n      if (isNode) localePath = await import('path').then((path) => path.join(root, format))\n    }\n    try {\n      const file = await readFile(localePath)\n      const xmlLangRe = /xml:lang=\"(.+)\"/\n      const localeName = file.match(xmlLangRe)[1]\n      config.locales.add(localeName, file)\n      return localeName\n    } catch (err) {\n      throw new Error(`Input locale option, ${format}, is invalid or is an unknown file.`)\n    }\n  } else {\n    return format\n  }\n}\n","import { fromDom } from 'hast-util-from-dom'\n\n/**\n * Convert HTML to HAST node\n *\n * @param {string} html\n */\nexport const htmlToHast = (html) => {\n  const frag = document.createRange().createContextualFragment(html)\n  return fromDom(frag).children[0]\n}\n","/**\n * @typedef {import('hast').Node} Node\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('unist-util-visit').Visitor<Node>} Visitor\n * @typedef {import('./parse-citation').CiteItem} CiteItem\n * @typedef {\"note\" | \"in-text\"} Mode\n * @typedef Options\n *   Configuration.\n * @property {string} [bibliography]\n *   Name of bibtex or CSL-JSON file\n * @property {string} [path]\n *   Optional path to file (node). Will be joined with `options.bibliography` and used in place of cwd of file if provided.\n * @property {'apa'|'vancouver'|'harvard1'|'chicago'|'mla'|string} [csl]\n *   One of 'apa', 'vancouver', 'harvard1', 'chicago', 'mla'. A local file path or URL to a valid CSL file is also accepted.\n * @property {string} [lang]\n *   Locale to use in formatting citations. Defaults to en-US. A local file path or URL to a valid locale file is also accepted.\n * @property {boolean} [suppressBibliography]\n *   By default, biliography is inserted after the entire markdown file.\n *   If the file contains `[^Ref]`, the biliography will be inserted there instead.\n * @property {string[]} [noCite]\n *   Citation IDs (@item1) to include in the bibliography even if they are not cited in the document\n * @property {string[]} [inlineClass]\n *   Class(es) to add to the inline citation.\n * @property {string[]} [inlineBibClass]\n *   Class(es) to add to the inline bibliography. Leave empty for no inline bibliography.\n */\n\nimport { visit } from 'unist-util-visit'\nimport fetch from 'cross-fetch'\nimport { parseCitation } from './parse-citation.js'\nimport { citeExtractorRe } from './regex.js'\nimport { isNode, isValidHttpUrl, readFile, getBibliography, loadCSL, loadLocale } from './utils.js'\nimport { htmlToHast } from './html-transform-node.js'\n\nconst defaultCiteFormat = 'apa'\nconst permittedTags = ['div', 'p', 'span', 'li']\nconst idRoot = 'CITATION'\n\n/**\n * Generate citation using citeproc\n * This accounts for prev citations and additional properties\n *\n * @param {*} citeproc\n * @param {Mode} mode\n * @param {CiteItem[]} entries\n * @param {number} citationId\n * @param {any[]} citationPre\n * @param {Options} options\n * @param {boolean} isComposite\n * @return {[string, string]}\n */\nconst genCitation = (citeproc, mode, entries, citationId, citationPre, options, isComposite) => {\n  const key = `${idRoot}-${citationId}`\n  const c = citeproc.processCitationCluster(\n    {\n      citationID: key,\n      citationItems: entries,\n      properties:\n        mode === 'in-text'\n          ? { noteIndex: 0, mode: isComposite ? 'composite' : '' }\n          : { noteIndex: citationId, mode: isComposite ? 'composite' : '' },\n    },\n    citationPre.length > 0 ? citationPre : [],\n    []\n  )\n\n  // console.log(Object.getOwnPropertyNames(citeproc.registry))\n  // console.log(citeproc.registry.citationreg.citationByIndex)\n  // c = [ { bibchange: true, citation_errors: [] }, [ [ 0, '(1)', 'CITATION-1' ] ]]\n  const citationText = c[1].find((x) => x[2] === key)[1]\n  const ids = `citation--${entries.map((x) => x.id.toLowerCase()).join('--')}--${citationId}`\n  if (mode === 'note') {\n    // Use cite-fn-{id} to denote footnote from citation, will clean it up later to follow gfm \"user-content\" format\n    return [\n      citationText,\n      htmlToHast(\n        `<span class=\"${(options.inlineClass ?? []).join(\n          ' '\n        )}\" id=${ids}><sup><a href=\"#cite-fn-${citationId}\" id=\"cite-fnref-${citationId}\" data-footnote-ref aria-describedby=\"footnote-label\">${citationId}</a></sup></span>`\n      ),\n    ]\n  }\n  // Coerce to html to parse HTML code e.g. &#38; and return text node\n  return [\n    citationText,\n    htmlToHast(\n      `<span class=\"${(options.inlineClass ?? []).join(' ')}\" id=${ids}>${citationText}</span>`\n    ),\n  ]\n}\n\n{\n  /* <section data-footnotes class=\"footnotes\"><h2 class=\"sr-only\" id=\"footnote-label\">Footnotes</h2>\n<ol>\n<li id=\"user-content-fn-1\">\n<p>First note <a href=\"#user-content-fnref-1\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n</ol>\n</section> */\n}\n\n/**\n * Create new footnote section node based on footnoteArray mappings\n *\n * @param {{int: string}} citationDict\n * @param {{type: 'citation' | 'existing', oldId: number}[]} footnoteArray\n * @param {Element | undefined} footnoteSection\n * @return {Element}\n */\nconst genFootnoteSection = (citationDict, footnoteArray, footnoteSection) => {\n  /** @type {Element} */\n  const list = {\n    type: 'element',\n    tagName: 'ol',\n    children: [{ type: 'text', value: '\\n' }],\n  }\n  let oldFootnoteList\n  if (footnoteSection) {\n    oldFootnoteList = footnoteSection.children.find((n) => n.tagName === 'ol')\n  }\n  for (const [idx, item] of footnoteArray.entries()) {\n    const { type, oldId } = item\n    if (type === 'citation') {\n      list.children.push({\n        type: 'element',\n        tagName: 'li',\n        properties: { id: `user-content-fn-${idx + 1}` },\n        children: [\n          {\n            type: 'element',\n            tagName: 'p',\n            properties: {},\n            children: [\n              htmlToHast(`<span>${citationDict[oldId]}</span>`),\n              {\n                type: 'element',\n                tagName: 'a',\n                properties: {\n                  href: `#user-content-fnref-${idx + 1}`,\n                  dataFootnoteBackref: true,\n                  className: ['data-footnote-backref'],\n                  ariaLabel: 'Back to content',\n                },\n                children: [{ type: 'text', value: '↩' }],\n              },\n            ],\n          },\n          { type: 'text', value: '\\n' },\n        ],\n      })\n    } else if (type === 'existing') {\n      // @ts-ignore\n      const liNode = oldFootnoteList.children.find(\n        (n) => n.tagName === 'li' && n.properties.id === `user-content-fn-${oldId}`\n      )\n      liNode.properties.id = `user-content-fn-${idx + 1}`\n      const aNode = liNode.children[1].children.find((n) => n.tagName === 'a')\n      aNode.properties.href = `#user-content-fnref-${idx + 1}`\n      list.children.push(liNode)\n    }\n  }\n\n  /** @type {Element} */\n  const newfootnoteSection = {\n    type: 'element',\n    tagName: 'section',\n    properties: { dataFootnotes: true, className: ['footnotes'] },\n    children: [\n      {\n        type: 'element',\n        tagName: 'h2',\n        properties: { className: ['sr-only'], id: 'footnote-label' },\n        children: [{ type: 'text', value: 'Footnotes' }],\n      },\n      { type: 'text', value: '\\n' },\n      list,\n    ],\n  }\n  return newfootnoteSection\n}\n\n/**\n * Generate bibliography in html and convert it to hast\n *\n * @param {*} citeproc\n */\nconst genBiblioNode = (citeproc) => {\n  const [params, bibBody] = citeproc.makeBibliography()\n  const bibliography =\n    '<div id=\"refs\" class=\"references csl-bib-body\">\\n' + bibBody.join('') + '</div>'\n  const biblioNode = htmlToHast(bibliography)\n\n  // Add citekey id to each bibliography entry.\n  biblioNode.children\n    .filter((node) => node.properties?.className?.includes('csl-entry'))\n    .forEach((node, i) => {\n      const citekey = params.entry_ids[i][0].toLowerCase()\n      node.properties = node.properties || {}\n      node.properties.id = 'bib-' + citekey\n    })\n  return biblioNode\n}\n\n/**\n * Rehype plugin that formats citations in markdown documents and insert bibliography in html format\n *\n *    [-@wadler1990]                              --> (1990)\n *    [@hughes1989, sec 3.4]                      --> (Hughes 1989, sec 3.4)\n *    [see @wadler1990; and @hughes1989, pp. 4]   --> (see Wadler 1990 and Hughes 1989, pp. 4)\n *\n * @param {*} Cite cite object from citation-js configured with the required CSLs\n * @return {import('unified').Plugin<[Options?], Root>}\n */\nconst rehypeCitationGenerator = (Cite) => {\n  return (options = {}) => {\n    return async (tree, file) => {\n      let bibliography = await getBibliography(options, file)\n      if (!bibliography) {\n        return\n      }\n\n      /** @type {string} */\n      let bibtexFile\n      /** @type {string} */ // @ts-ignore\n      const inputCiteformat = options.csl || file?.data?.frontmatter?.csl || defaultCiteFormat\n      const inputLang = options.lang || 'en-US'\n      const config = Cite.plugins.config.get('@csl')\n      const citeFormat = await loadCSL(Cite, inputCiteformat, options.path)\n      const lang = await loadLocale(Cite, inputLang, options.path)\n\n      if (isValidHttpUrl(bibliography)) {\n        isNode\n        const response = await fetch(bibliography)\n        bibtexFile = await response.text()\n      } else {\n        if (isNode) {\n          bibtexFile = await readFile(bibliography)\n        } else {\n          throw new Error(`Cannot read non valid bibliography URL in node env.`)\n        }\n      }\n\n      const citations = new Cite(bibtexFile)\n      const citationIds = citations.data.map((x) => x.id)\n      const citationPre = []\n      const citationDict = {}\n      let citationId = 1\n      const citeproc = config.engine(citations.data, citeFormat, lang, 'html')\n      /** @type {Mode} */\n      const mode = citeproc.opt.xclass\n\n      visit(tree, 'text', (node, idx, parent) => {\n        const match = node.value.match(citeExtractorRe)\n        //@ts-ignore\n        if (!match || !permittedTags.includes(parent.tagName)) return\n        const citeStartIdx = match.index\n        const citeEndIdx = match.index + match[0].length\n        const newChildren = []\n        // if preceding string\n        if (citeStartIdx !== 0) {\n          // create a new child node\n          newChildren.push({\n            type: 'text',\n            value: node.value.slice(0, citeStartIdx),\n          })\n        }\n\n        const [entries, isComposite] = parseCitation(match[0])\n\n        // If id is not in citation file (e.g. route alias or js package), abort process\n        for (const citeItem of entries) {\n          if (!citationIds.includes(citeItem.id)) return\n        }\n        const [citedText, citedTextNode] = genCitation(\n          citeproc,\n          mode,\n          entries,\n          citationId,\n          citationPre,\n          options,\n          isComposite\n        )\n        citationDict[citationId] = citedText\n\n        // Prepare citationPre and citationId for the next cite instance\n        citationPre.push([`${idRoot}-${citationId}`, 0])\n        citationId = citationId + 1\n\n        // TODO: return html with link\n        newChildren.push(citedTextNode)\n\n        // if trailing string\n        if (citeEndIdx < node.value.length) {\n          newChildren.push({\n            type: 'text',\n            value: node.value.slice(citeEndIdx),\n          })\n        }\n\n        // insert into the parent\n        // @ts-ignore\n        parent.children = [\n          ...parent.children.slice(0, idx),\n          ...newChildren,\n          ...parent.children.slice(idx + 1),\n        ]\n      })\n\n      if (options.noCite) {\n        citeproc.updateItems(options.noCite.map((x) => x.replace('@', '')))\n      }\n\n      if (\n        citeproc.registry.mylist.length >= 1 &&\n        (!options.suppressBibliography || options.inlineBibClass?.length > 0)\n      ) {\n        const biblioNode = genBiblioNode(citeproc)\n        let bilioInserted = false\n\n        const biblioMap = {}\n        biblioNode.children\n          .filter((node) => node.properties?.className?.includes('csl-entry'))\n          .forEach((node) => {\n            const citekey = node.properties.id.split('-').slice(1).join('-')\n            biblioMap[citekey] = { ...node }\n            biblioMap[citekey].properties = { id: 'inlinebib-' + citekey }\n          })\n\n        // Insert it at ^ref, if not found insert it as the last element of the tree\n        visit(tree, 'element', (node, idx, parent) => {\n          // Add inline bibliography\n          if (\n            options.inlineBibClass?.length > 0 &&\n            node.properties?.id?.toString().startsWith('citation-')\n          ) {\n            // id is citation--nash1951--nash1950--1\n            const [, ...citekeys] = node.properties.id.toString().split('--')\n            const citationID = citekeys.pop()\n\n            const inlineBibNode = {\n              type: 'element',\n              tagName: 'div',\n              properties: {\n                className: options.inlineBibClass,\n                id: `inlineBib--${citekeys.join('--')}--${citationID}`,\n              },\n              children: citekeys.map((citekey) => {\n                const aBibNode = biblioMap[citekey]\n                aBibNode.properties = {\n                  class: 'inline-entry',\n                  id: `inline--${citekey}--${citationID}`,\n                }\n                return aBibNode\n              }),\n            }\n            parent.children.push(inlineBibNode)\n          }\n\n          // Add bibliography\n          if (\n            !options.suppressBibliography &&\n            (node.tagName === 'p' || node.tagName === 'div') &&\n            node.children[0].value === '[^ref]'\n          ) {\n            parent.children[idx] = biblioNode\n            bilioInserted = true\n          }\n        })\n\n        if (!options.suppressBibliography && !bilioInserted) {\n          tree.children.push(biblioNode)\n        }\n      }\n\n      let footnoteSection\n      visit(tree, 'element', (node, index, parent) => {\n        if (node.tagName === 'section' && node.properties.dataFootnotes) {\n          footnoteSection = node\n          parent.children.splice(index, 1)\n        }\n      })\n\n      // Need to adjust footnote numbering based on existing ones already assigned\n      // And insert them into the footnote section (if exists)\n      // Footnote comes after bibliography\n      if (mode === 'note' && Object.keys(citationDict).length > 0) {\n        /** @type {{type: 'citation' | 'existing', oldId: number}[]} */\n        let fnArray = []\n        let index = 1\n        visit(tree, 'element', (node) => {\n          if (node.tagName === 'sup') {\n            let nextNode = node.children[0]\n            if (nextNode.tagName === 'a') {\n              // @ts-ignore\n              const { href, id } = nextNode.properties\n              if (href.includes('fn') && id.includes('fnref')) {\n                const oldId = href.split('-').pop()\n                fnArray.push({\n                  type: href.includes('cite') ? 'citation' : 'existing',\n                  oldId,\n                })\n                // Update ref number\n                // @ts-ignore\n                nextNode.properties.href = `#user-content-fn-${index}`\n                // @ts-ignore\n                nextNode.properties.id = `user-content-fnref-${index}`\n                nextNode.children[0].value = index.toString()\n                index += 1\n              }\n            }\n          }\n        })\n        // @ts-ignore\n        const newFootnoteSection = genFootnoteSection(citationDict, fnArray, footnoteSection)\n        tree.children.push(newFootnoteSection)\n      } else {\n        if (footnoteSection) tree.children.push(footnoteSection)\n      }\n    }\n  }\n}\n\nexport default rehypeCitationGenerator\n"],"names":["citeExtractorRe","citeKeyRe","citeBracketRe","locatorMapping","book","chapter","column","figure","folio","number","line","note","opus","page","paragraph","part","section","verse","volume","readFile","async","isValidHttpUrl","path","fetch","then","response","text","data","Error","str","url","URL","_","protocol","htmlToHast","html","frag","document","createRange","createContextualFragment","fromDom","children","permittedTags","rehypeCitationGenerator","Cite","options","tree","file","bibtexFile","bibliography","_file$data","frontmatter","_file$data$frontmatte","getBibliography","inputCiteformat","csl","inputLang","lang","config","plugins","get","citeFormat","format","root","Object","keys","templates","includes","cslName","Math","random","toString","slice","cslPath","add","err","loadCSL","locales","localePath","localeName","match","loadLocale","citations","citationIds","map","x","id","citationPre","citationDict","citationId","citeproc","engine","mode","opt","xclass","visit","node","idx","parent","value","tagName","citeStartIdx","index","citeEndIdx","length","newChildren","push","type","entries","isComposite","citeString","test","citeItems","substr","split","citeItem","prefix","locator","label","suffix","citeChunk","trim","suppressAuthor","indexOf","commaIndex","undefined","citeKey","afterKey","locatorMatch","parseCitation","citedText","citedTextNode","key","citationText","processCitationCluster","citationID","citationItems","properties","noteIndex","find","ids","toLowerCase","join","inlineClass","genCitation","noCite","updateItems","replace","registry","mylist","suppressBibliography","inlineBibClass","biblioNode","params","bibBody","makeBibliography","filter","_node$properties","className","_node$properties$clas","forEach","i","citekey","entry_ids","genBiblioNode","bilioInserted","biblioMap","_node$properties2","_node$properties2$cla","_node$properties3","_node$properties3$id","startsWith","citekeys","pop","inlineBibNode","aBibNode","class","footnoteSection","dataFootnotes","splice","fnArray","nextNode","href","oldId","newFootnoteSection","footnoteArray","list","oldFootnoteList","n","item","dataFootnoteBackref","ariaLabel","liNode","genFootnoteSection"],"mappings":"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"}